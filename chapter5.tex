\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{ctex}
\geometry{left=3cm,right=3cm,top=2.5cm,bottom=2.5cm}

\newtheorem{theorem}{定理}
\newtheorem{lemma}{引理}
\newtheorem{definition}{定义}
\newtheorem{claim}{主张}

\title{问题一：分析与求解}
\author{（作者）}
\date{}

\begin{document}
\maketitle

\section{问题一分析与求解}

\subsection{问题一建模与复杂性分析}
\label{subsec:problem1_analysis}

问题一要求在忽略硬件缓存容量物理限制（即假设L1与UB缓存无限）的前提下，为给定的有向无环图（DAG）计算图生成一个满足拓扑约束的节点调度序列，使得执行过程中L1与UB缓存的峰值占用量最小化。同时，需满足L0级缓存（L0A、L0B、L0C）的互斥约束：任意时刻，每类L0缓存至多仅允许一个缓冲区驻留。

该问题可抽象为一个带资源约束的拓拓扑排序优化问题，其目标函数为调度序列执行过程中的最大瞬时缓存占用量。我们首先通过归约方法证明该问题是NP难的，继而提出一种基于贪心策略与反向拓扑传播优先级评估的启发式调度算法，以在多项式时间内获得高质量近似解。

\subsubsection{最小峰值内存调度问题（Minimum Peak Memory Scheduling Problem）}
\label{subsubsec:min_peak_problem}

最小峰值内存调度问题（MPMSP）是调度理论中的经典NP难问题，其定义如下：

\begin{definition}[最小峰值内存调度问题]
给定一个DAG $ G = (V, E) $，其中每个节点 $ v \in V $ 关联一个内存需求 $ s(v) \in \mathbb{N}^+ $（若为ALLOC节点）或内存释放量 $ -s(v) $（若为FREE节点），目标是寻找一个拓扑排序 $ \pi: V \to \{1, 2, \dots, |V|\} $，使得执行序列中任意时刻的累计内存占用量最大值最小化：
\[
\min_{\pi \in \text{Topo}(G)} \max_{1 \leq k \leq |V|} \left| \sum_{i=1}^{k} \Delta m(\pi(i)) \right|
\]
其中 $ \Delta m(v) = \begin{cases} 
+s(v) & \text{if } v \text{ is ALLOC} \\
-s(v) & \text{if } v \text{ is FREE}
\end{cases} $，且 $ \text{Topo}(G) $ 表示所有满足DAG拓扑序的排列集合。
\end{definition}

MPMSP已被广泛研究，并被证明是强NP难的\cite{Liu2017Memory}。其难点在于节点调度顺序直接影响内存生命周期重叠程度，而最优调度需全局协调所有资源分配与释放时机。

\subsubsection{问题一的NP难性证明}
\label{subsubsec:reduction}

为证明本题的NP难性，我们构造一个从MPMSP到本问题的多项式时间归约。

\begin{theorem}
问题一（最小缓存驻留调度）是NP难的。
\end{theorem}

\begin{proof}
设存在一个MPMSP实例 $ I = (G, s) $，其中 $ G = (V, E) $ 为DAG，$ s: V \to \mathbb{N}^+ $ 为内存需求函数。我们构造一个对应的本问题实例 $ I' $ 如下：

\begin{itemize}
    \item 对每个节点 $ v \in V $，在 $ I' $ 中创建两个节点：一个ALLOC节点 $ a_v $ 和一个FREE节点 $ f_v $。
    \item 设置 $ a_v.\text{BufId} = f_v.\text{BufId} = v $，$ a_v.\text{Size} = f_v.\text{Size} = s(v) $，且缓存类型均为UB。
    \item 对 $ G $ 中的每条边 $ (u, v) \in E $，在 $ I' $ 中添加一条依赖边 $ (f_u, a_v) $。
    \item 对每个节点 $ v \in V $，在 $ I' $ 中添加一条依赖边 $ (a_v, f_v) $。
\end{itemize}
该构造可在多项式时间内完成。在此构造下，$ I' $ 的调度问题与 $ I $ 的MPMSP问题等价。由于L0互斥约束在本构造中未被激活，因此 $ I' $ 的最优解对应于 $ I $ 的最优解。鉴于MPMSP是NP难的，故本问题也是NP难的。
\end{proof}

\subsection{基于贪心策略的启发式调度算法}
\label{subsec:heuristic_algorithm}
由于问题一的NP难特性，我们设计了一种高效的启发式算法，旨在多项式时间内生成高质量的近似解。该算法的核心思想是采用一种贪心策略，通过为所有无前驱依赖的ALLOC根节点计算优先级分数，从而确定一个优化的初始调度序列。其设计原则总结如下：
\begin{enumerate}[noitemsep]
  \item 保证产生的序列满足 DAG 的拓扑约束（即任何时刻只能选择所有前驱已调度的“就绪”节点进行调度）。
  \item 就绪节点之间采用分层优先级：优先调度能释放大量空间的 \(\mathrm{FREE}\) 节点，其次为普通操作节点（\(\mathrm{OP}\)），最后考虑 \(\mathrm{ALLOC}\) 节点，从而尽可能在早期降低当前驻留内存。
  \item 对 \(\mathrm{ALLOC}\) 节点采用精细化优先级：优先调度能最快降低未来内存压力的\(\mathrm{ALLOC}\) 节点。这一决策基于一个反向拓扑传播的评分模型，该模型从图的叶子节点（\(\mathrm{FREE}\)节点）出发，将未来可释放的内存量作为“收益”反向拓扑传播至图的根节点（\(\mathrm{ALLOC}\) 节点）。
  \item 在 L0 类型（L0A/L0B/L0C）互斥约束下，采用计数器维护当前已分配 L0 类型资源并对待调度的 \(\mathrm{ALLOC}\) 节点进行阻塞与快速唤醒（使用双指针以实现批量或连续唤醒的低开销）。
\end{enumerate}

\subsubsection{针对L0互斥约束的优先级策略}
为了处理L0缓存的互斥约束，算法首先将所有ALLOC根节点划分为两个独立的优先级组：
\begin{itemize}
    \item \textbf{L0组 ($R_{L0}$)}：所有在L0A, L0B, L0C缓存上分配空间的ALLOC节点。
    \item \textbf{非L0组 ($R_{\neg L0}$)}：所有在L1, UB等其他缓存上分配空间的ALLOC节点。
\end{itemize}
初始阶段时认为L0组的节点拥有绝对优先级，即所有L0组的节点必须在任何非L0组的节点之前被调度。这一策略旨在尽早处理具有严格互斥约束的L0资源，以最大程度地降低因资源竞争而引发死锁的可能性。

\subsubsection{组内优先级评估模型}
在每个优先级组内部，节点的相对顺序由一个精细的评分系统决定。我们设计了两个独立的分数，$S_1$和$S_2$，分别用于$R_{\neg L0}$组和$R_{L0}$组的内部排序。

\paragraph{Score1 ($S_1$)：非L0组的优先级分数}
$S_1$分数旨在量化一个ALLOC节点在未来能够“解锁”的内存释放总量。
\begin{itemize}
    \item \textbf{分数初始化}：对于图中的每个叶子节点（FREE节点）$l$，其初始分数$S_1(l)$定义为其释放的内存大小的负值。为了激励尽早释放L0缓存，我们引入权重$\omega_{L0} > 1$（本研究中取$\omega_{L0}=3$）。
    \[
    S_1(l) = \begin{cases} 
    -\omega_{L0} \cdot \text{size}(l) & \text{if } l \text{ frees an L0 buffer} \\
    -\text{size}(l) & \text{otherwise}
    \end{cases}
    \]
    \item \textbf{分数传播}：分数从叶子节点沿反向拓扑序向其父节点传播。对于一个节点$v$，其分数$S_1(v)$会累加到其所有直接父节点$p \in \text{Parents}(v)$上。
    \[
    S_1(p) \leftarrow S_1(p) + \alpha_1 \cdot S_1(v)
    \]
    其中，传播因子$\alpha_1=1$。最终，每个根节点$r$的$S_1(r)$值表示其所有下游路径可释放的内存总量的加权和。$S_1$值越小（即负得越多），表示其下游可释放的内存越多，优先级越高。
\end{itemize}

\paragraph{Score2 ($S_2$)：L0组的优先级分数}
$S_2$分数的设计目标是评估一个L0 ALLOC节点下游的拓扑结构复杂度，优先处理分支较多的节点以避免死锁。
\begin{itemize}
    \item \textbf{分数初始化}：$S_2$的计算忽略L0缓存的释放量，仅关注拓扑结构。
    \[
    S_2(l) = \begin{cases} 
    0 & \text{if } l \text{ frees an L0 buffer} \\
    -\text{size}(l) & \text{otherwise}
    \end{cases}
    \]
    \item \textbf{分数传播}：传播规则为：
    \[
    S_2(p) \leftarrow S_2(p) + (1 + \alpha_2 \cdot S_2(v))
    \]
    其中，传播因子$\alpha_2$通常是一个较小值，这意味着，首先根据分支 $\alpha_2 \cdot S_2(v)$项仅在两个ALLOC节点分支数量相近的情况下才起主要作用。公式简化为$S_2(p) \leftarrow S_2(p) + 1$。这意味着，一个节点的$S_2$分数近似等于其下游的路径分支数量。$S_2$值越大，代表其下游拓扑结构越复杂。
\end{itemize}

\subsubsection{最终调度序列生成}
获得原始分数后，我们通过归一化和加权求和来计算每个根节点的最终总分。
\begin{enumerate}
    \item \textbf{分数归一化}：对所有根节点$r \in R = R_{L0} \cup R_{\neg L0}$，分别对$S_1(r), S_2(r)$以及节点申请的内存大小$\text{size}(r)$进行最小-最大归一化，映射到$[0, 1]$区间。
    \[
    \text{norm}(x) = \frac{x - \min(X)}{\max(X) - \min(X)}
    \]
    \item \textbf{总分计算}：
    \begin{align*}
    S_{\text{total},1}(r) &= \text{norm}(S_1(r)) + w_{\text{size}} \cdot \text{norm}(\text{size}(r)) \quad (\text{for } r \in R_{\neg L0}) \\
    S_{\text{total},2}(r) &= \text{norm}(S_2(r)) + w_{\text{size}} \cdot \text{norm}(\text{size}(r)) \quad (\text{for } r \in R_{L0})
    \end{align*}
    其中$w_{\text{size}}$是一个极小的权重（本研究中取$10^{-10}$），使得节点大小仅作为次要的排序依据。
    \item \textbf{排序与合并}：
    \begin{itemize}
        \item $R_{\neg L0}$组根据$S_{\text{total},1}$升序排序。
        \item $R_{L0}$组根据$S_{\text{total},2}$升序排序。
    \end{itemize}
    最终的根节点调度序列$\pi_{\text{root}}$由排序后的$R_{L0}$组和$R_{\neg L0}$组顺序拼接而成。
\end{enumerate}

\subsubsection{算法伪代码与复杂度分析}
算法的整体流程如算法\ref{alg:schedule}所示。

\begin{algorithm}
\caption{启发式调度算法}
\label{alg:schedule}
\begin{algorithmic}[1]
\STATE \textbf{Input:} 有向无环图 $G=(V, E)$
\STATE \textbf{Output:} 根节点调度序列 $\pi_{\text{root}}$

\FUNCTION{CalculateScore}{$G$, score\_type}
    \STATE 初始化所有节点的score为0
    \STATE $Q \leftarrow$ 图$G$中所有出度为0的节点（叶子节点）
    \FOR{$l$ in $Q$}
        \IF{score\_type is 1}
            \STATE 根据$S_1$规则初始化$l.score$
        \ELSE
            \STATE 根据$S_2$规则初始化$l.score$
        \ENDIF
    \ENDFOR
    \WHILE{$Q$ is not empty}
        \STATE $v \leftarrow Q.popleft()$
        \FOR{$p$ in Parents($v$)}
            \IF{score\_type is 1}
                \STATE $p.score \leftarrow p.score + \alpha_1 \cdot v.score$
            \ELSE
                \STATE $p.score \leftarrow p.score + (1 + \alpha_2 \cdot v.score)$
            \ENDIF
            \STATE $p.out\_degree \leftarrow p.out\_degree - 1$
            \IF{$p.out\_degree = 0$}
                \STATE $Q.append(p)$
            \ENDIF
        \ENDFOR
    \ENDWHILE
\ENDFUNCTION

\STATE
\STATE // 主流程
\STATE $S_1 \leftarrow$ CalculateScore($G$, 1)
\STATE $S_2 \leftarrow$ CalculateScore($G$, 2)
\STATE $R \leftarrow$ 图$G$中所有入度为0的ALLOC节点（根节点）
\STATE $R_{L0} \leftarrow \{r \in R \mid r.\text{type} \in \{\'L0A\', \'L0B\', \'L0C\'\}\}$
\STATE $R_{\neg L0} \leftarrow R \setminus R_{L0}$
\STATE 对$R$中节点的$S_1, S_2, \text{size}$进行归一化
\STATE 为$R_{L0}$中每个节点计算$S_{\text{total},2}$
\STATE 为$R_{\neg L0}$中每个节点计算$S_{\text{total},1}$
\STATE Sort $R_{L0}$ in ascending order of $S_{\text{total},2}$
\STATE Sort $R_{\neg L0}$ in ascending order of $S_{\text{total},1}$
\STATE $\pi_{\text{root}} \leftarrow \text{concatenate}(R_{L0}, R_{\neg L0})$
\STATE \textbf{return} $\pi_{	ext{root}}$
\end{algorithmic}
\end{algorithm}

\paragraph{复杂度分析}
该算法的主要计算开销在于分数计算过程。`CalculateScore`函数本质上是对图进行一次反向拓扑遍历，其时间复杂度为$O(|V| + |E|)$，其中$|V|$是节点数，$|E|$是边数。该过程执行两次。后续的根节点分组、归一化和排序步骤的时间复杂度为$O(|R|\log|R|)$，其中$|R|$是根节点的数量。由于$|R| \leq |V|$，算法的整体时间复杂度由图遍历主导，为$O(|V| + |E|)$，能够在多项式时间内为大规模计算图生成高质量的调度序列。

\end{document}